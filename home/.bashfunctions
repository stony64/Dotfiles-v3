#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# FILE:        .bashfunctions
# VERSION:     1.8.2
# DESCRIPTION: Power Bash Functions - Optimized for Proxmox & Framework
#              Designed to work in tandem with .bashaliases
# AUTHOR:      Stony64
# ------------------------------------------------------------------------------

# ShellCheck Konfiguration
# shellcheck source=/dev/null disable=SC2034

# --- 0. BOOTSTRAP (Logging & UI) ----------------------------------------------
# Ermöglicht konsistente Statusmeldungen, auch wenn das Core-Framework fehlt.
if ! command -v df_log_error >/dev/null 2>&1; then
    df_log_error()   { printf '\033[31m[ERR]\033[0m %s\n' "$*" >&2; }
    df_log_success() { printf '\033[32m[OK]\033[0m %s\n' "$*"; }
    df_log_info()    { printf '\033[34m-->\033[0m %s\n' "$*"; }
    df_log_warn()    { printf '\033[33m[!]\033[0m %s\n' "$*"; }
fi

# --- 1. ARCHIVIERUNG & EXTRAKTION ---------------------------------------------

# Komprimiert Dateien/Ordner mit maximaler XZ-Kompression
df_compress() {
    local name="$1" source="$2" target
    if [[ -z "$name" || -z "$source" ]]; then
        df_log_error "Usage: df_compress <target_name> <source_path>"
        return 1
    fi
    target="${name}.tar.xz"
    df_log_info "Compressing $source to $target..."
    if tar -cvJf "$target" -- "$source"; then
        df_log_success "Done: $target ($(du -h "$target" | cut -f1))"
    else
        df_log_error "Compression failed."
        return 1
    fi
}

# Universal-Extraktor: ShellCheck SC2181 konform (direkter Exit-Code Check)
extract() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        df_log_error "File not found: $file"
        return 1
    fi

    local dir="${file%.*}"
    [[ "$file" =~ \.tar\..* ]] && dir="${file%.tar.*}"

    # Befehl wird direkt im 'if' ausgeführt, um $? Fallstricke zu vermeiden
    if case "${file,,}" in
        *.tar.bz2|*.tbz2|*.tbz) tar xjf "$file" ;;
        *.tar.gz|*.tgz)         tar xzf "$file" ;;
        *.tar.xz|*.txz)         tar xJf "$file" ;;
        *.tar.zst)              unzstd -c "$file" | tar xf - ;;
        *.zip)                  unzip -q "$file" -d "${dir}" ;;
        *.7z)                   7z x "$file" -o"${dir}" ;;
        *.rar)                  unrar x "$file" ;;
        *.gz)                   gunzip -k "$file" ;;
        *.bz2)                  bunzip2 -k "$file" ;;
        *.xz)                   unxz -k "$file" ;;
        *)                      df_log_error "Format not supported: $file"; return 1 ;;
    esac; then
        df_log_success "Extracted: $file"
        # Automatisch in den neuen Ordner wechseln, falls einer erstellt wurde
        [[ -d "$dir" ]] && cd "$dir" || return 0
    else
        df_log_error "Extraction failed."
        return 1
    fi
}

# --- 2. INTELLIGENTE SUCHE ----------------------------------------------------

# History-Grep: Durchsucht die Befehlshistorie effizient
hg() {
    [[ -z "$1" ]] && { df_log_error "Usage: hg <term>"; return 1; }
    # Schneidet führende Nummern ab, um nur den Befehl zu greppen
    history | cut -c 8- | grep -i --color=always -- "$1" | tail -20
}

# Schnellsuche für Dateien (max. 4 Ebenen tief, ohne Müll)
ff() {
    [[ -z "$1" ]] && { df_log_error "Usage: ff <name>"; return 1; }
    find . -maxdepth 4 -iname "*$1*" -not -path '*/\.*' -not -path '*/node_modules/*' 2>/dev/null | head -20
}

# Inhalts-Suche: Durchsucht Dateiinhalte (Grep-Power-Alias)
ft() {
    local term="$1" mask="${2:-*}"
    [[ -z "$term" ]] && { df_log_error "Usage: ft <text> [mask]"; return 1; }
    grep -rniI --color=always \
        --exclude-dir={.git,node_modules,build,dist,.venv} \
        --include="*$mask*" -- "$term" . 2>/dev/null | head -50
}

# --- 3. METADATEN & DISCOVERY -------------------------------------------------

# Listet alle aktiven Aliase tabellarisch auf
show_aliases() {
    df_log_info "Active Aliases ($(alias | wc -l)):"
    alias | sed 's/^alias //' | column -t -s'=' | less -R
}

# Listet geladene User-Funktionen (filtert interne df_ / _ Funktionen)
show_functions() {
    df_log_info "User Functions ($(declare -F | wc -l)):"
    declare -F | awk '{print $NF}' | grep -vE '^(_|df_)' | sort | column | less -R
}

# --- 4. NAVIGATION & STRUKTUR -------------------------------------------------

# Verzeichnis erstellen und sofort hineinwechseln
mkd() {
    mkdir -p -- "$@" && cd -- "${1:-.}" || return 1
}

# Verzeichnis-Struktur-Anzeige (Tree mit Fallback auf Find)
lt() {
    local target="${1:-.}"
    # FIX SC2015: Echtes if-else statt && || Konstrukt
    if command -v tree >/dev/null 2>&1; then
        tree -aC -I '.git|node_modules|.DS_Store|backup' --dirsfirst "$target" | head -n 40
    else
        find "$target" -maxdepth 2 -not -path '*/\.*' | sed 's|^\./||' | column
    fi
}

# --- 5. SYSTEM & NETZWERK -----------------------------------------------------

# Zeigt lokale und öffentliche IP mit Timeout-Schutz
df_myip() {
    local local_ipv4 pub_ip
    local_ipv4="$(hostname -I | awk '{print $1}')"
    [[ -n "$local_ipv4" ]] && df_log_info "Local:  $local_ipv4"

    pub_ip="$(curl -s --connect-timeout 2 --max-time 3 https://api.ipify.org 2>/dev/null || \
             curl -s --connect-timeout 2 https://ifconfig.me 2>/dev/null)"

    if [[ -n "$pub_ip" ]]; then
        df_log_success "Public: $pub_ip"
    else
        df_log_warn "Public IP: Offline / Timeout"
    fi
}

# Port-Belegung prüfen
port() {
    [[ -z "$1" ]] && { df_log_error "Usage: port <number>"; return 1; }
    ss -tulpn | grep -E "Netid|:$1"
}

# --- 6. PROXMOX & CLEANUP -----------------------------------------------------

# PVE-Node Status Übersicht (jq optimiert)
pve_status() {
    if ! command -v pvesh >/dev/null 2>&1; then
        df_log_error "Proxmox CLI (pvesh) not found."
        return 1
    fi

    if command -v jq >/dev/null 2>&1; then
        pvesh get /nodes --output-format json | jq -r '.[] | "Node: \(.node) | Status: \(.status) | CPU: \((.cpu*100|round))% | RAM: \((.mem/1024/1024/1024|round))GB"'
    else
        pvesh get /nodes --output-format text
    fi
}

# Entfernt tote Symlinks zuverlässig (SC2015 korrigiert)
df_clean_links() {
    local link count=0
    # Suche tote Links (Existierende Links ohne Ziel)
    while read -r link; do
        if rm -v "$link" 2>/dev/null; then
            ((count++))
        fi
    done < <(find . -maxdepth 2 -xtype l)

    # Korrektur SC2015: if-else Logik
    if [[ $count -gt 0 ]]; then
        df_log_success "Cleaned $count dead links."
    else
        df_log_info "No dead links found."
    fi
}
